---
title: FreeCodeCamp 高级算法题 - 计算找零
date: 2017-08-22 23:50:22
tags: [FreeCodeCamp,高级,算法]
categories: FCC
---

# 计算找零 (Exact Change)

## 题目链接
- [中文链接](https://freecodecamp.cn/challenges/exact-change)
- [英文链接](https://freecodecamp.com/challenges/exact-change)

## 问题解释
- 这个 `function` 接收三个参数，`price` 为购买总价，`cash` 为付款金额，`cid` 为收银机中可用的零钱。返回值为应找回的零钱列表
- 需要注意的是，`cid` 中，每个子数组的第一个元素代表面值，第二个元素代表这个面值的总额。比如 `["TEN", 30.00]` 就表示十元纸币共有 `30` 元，即三张
- 如果 `price` 为 `19.50`，`cash` 为 `20.00`，`cid` 为 `[["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.10], ["QUARTER", 4.25], ["ONE", 90.00], ["FIVE", 55.00], ["TEN", 20.00], ["TWENTY", 60.00], ["ONE HUNDRED", 100.00]]`，则返回值应为 `[["QUARTER", 0.50]]`

<!--more-->

# 解题思路
- 可能有些朋友不知道美元的硬币面值，`"PENNY"` 代表一分，`"NICKEL"` 代表五分，`"DIME"` 代表一角，`"QUARTER"` 代表二十五分 (两毛五)
- 首先，计算出找零金额不难，直接用 `cash` 减去 `price` 就可以了
- 根据 `cid`，我们可以很明确地知道零钱的总额。如果这个总额小于应找金额则应返回 `"Insufficient Funds"`，如果这个总额等于应找金额则应返回 `"Closed"`。这两个条件我们可以在一开始判断，如果符合即可直接返回，不需要进行任何其他的计算
- 可以回想一下[罗马数字转换器](http://singsing.io/blog/fcc/intermediate-roman-numeral-converter/)那道题。在那道题中，我们的思路就是先写一个可用字母代表的数字组成的数组，然后从数组中最大的数开始与给定的数字比较，只要是小于等于原数字，就减去匹配到的数字，得到的结果继续进行匹配。尽管还涉及一些特殊情况，但整体思路是这样
- 这道题同理，我们先生成一个零钱面值数组，然后对应找金额进行迭代就可以了
- 比如说，应找金额为 `23.5` 元
    - 显然我们是不需要 100 元的。我们需要先凑出来二十。如果我们有 20 元，就应该直接给一张。如果没有，那就应该继续找，看有没有两张十块。以此类推。这一步完成后再去凑剩下的三块五
    - 对于三块五，我们要先凑三块钱出来。显然我们是不需要 5 元的。只需要看看有没有三张 1 元。如果没有，就要继续找，看看硬币的 Quarter 够不够，以此类推
    - 最后再凑五角，显然我们应该从 Quarter 开始试，两个 Quarter 就可以。如果没有，就看看有没有五个 Dime，以此类推
- 显然，如果计算到中间的步骤，比如五角这一步。就算前面都可以满足，但这时候发现任何一个面值都没法付清五角，那就表示我们没法付清找零，因此就应该直接跳出，返回 `"Insufficient Funds"`