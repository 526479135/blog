---
title: FreeCodeCamp 高级算法题 - 计算找零
date: 2017-08-22 23:50:22
tags: [FreeCodeCamp,高级,算法]
categories: FCC
---

# 计算找零 (Exact Change)

## 题目链接
- [中文链接](https://freecodecamp.cn/challenges/exact-change)
- [英文链接](https://freecodecamp.com/challenges/exact-change)

## 问题解释
- 这个 `function` 接收三个参数，`price` 为购买总价，`cash` 为付款金额，`cid` 为收银机中可用的零钱。返回值为应找回的零钱列表
- 需要注意的是，`cid` 中，每个子数组的第一个元素代表面值，第二个元素代表这个面值的总额。比如 `["TEN", 30.00]` 就表示十元纸币共有 `30` 元，即三张
- 如果 `price` 为 `19.50`，`cash` 为 `20.00`，`cid` 为 `[["PENNY", 1.01], ["NICKEL", 2.05], ["DIME", 3.10], ["QUARTER", 4.25], ["ONE", 90.00], ["FIVE", 55.00], ["TEN", 20.00], ["TWENTY", 60.00], ["ONE HUNDRED", 100.00]]`，则返回值应为 `[["QUARTER", 0.50]]`

<!--more-->

# 解题思路
- 可能有些朋友不知道美元的硬币面值，`"PENNY"` 代表一分，`"NICKEL"` 代表五分，`"DIME"` 代表一角，`"QUARTER"` 代表二十五分 (两毛五)
- 首先，计算出找零金额不难，直接用 `cash` 减去 `price` 就可以了
- 根据 `cid`，我们可以很明确地知道零钱的总额。如果这个总额小于应找金额则应返回 `"Insufficient Funds"`，如果这个总额等于应找金额则应返回 `"Closed"`。这两个条件我们可以在一开始判断，如果符合即可直接返回，不需要进行任何其他的计算
- 可以回想一下[罗马数字转换器](http://singsing.io/blog/fcc/intermediate-roman-numeral-converter/)那道题。在那道题中，我们的思路就是先写一个可用字母代表的数字组成的数组，然后从数组中最大的数开始与给定的数字比较，只要是小于等于原数字，就减去匹配到的数字，得到的结果继续进行匹配。尽管还涉及一些特殊情况，但整体思路是这样
- 这道题同理，我们先生成一个零钱面值数组，然后对应找金额进行迭代就可以了
- 比如说，应找金额为 `23.5` 元
    - 显然我们是不需要 100 元的。我们需要先凑出来二十。如果我们有 20 元，就应该直接给一张。如果没有，那就应该继续找，看有没有两张十块。以此类推。这一步完成后再去凑剩下的三块五
    - 对于三块五，我们要先凑三块钱出来。显然我们是不需要 5 元的。只需要看看有没有三张 1 元。如果没有，就要继续找，看看硬币的 Quarter 够不够，以此类推
    - 最后再凑五角，显然我们应该从 Quarter 开始试，两个 Quarter 就可以。如果没有，就看看有没有五个 Dime，以此类推
- 显然，如果计算到中间的步骤，比如五角这一步。就算前面都可以满足，但这时候发现任何一个面值都没法付清五角，那就表示我们没法付清找零，因此就应该直接跳出，返回 `"Insufficient Funds"`

# 注意事项 - 关于浮点数
- 在绝大部分计算机语言中，小数都是允许使用的，JavaScript 也不例外。只是限于 [IEEE 754 标准](http://grouper.ieee.org/groups/754/)，很多语言处理浮点数会出现问题。比如 JavaScript 中很经典的 `0.1 + 0.2 === 0.3` 返回 `false`。**这个不是 JavaScript 语言本身的问题，而是浮点数需要以二进制形式存储。**
- 内部的原理，大致上是这样。比如 `0.1`，首先它等于 `1/10`，但 `10` 并不是一个二进制数。对于 `1/10`，我们需要用二进制数来无限接近它，`1/8` 显然不可能，因为它已经比 `1/10` 大了。那我们可以表示为：
```js
0.1 = 1/10 = 1/16 + (1/10 - 1/16)
```

- 计算 `1/10 - 1/16`，我们得到 `0.0375`。进而可以表示为：
```js
0.0375 = 1/32 + (0.0375 - 1/32)
```

- 然后继续运算。这样就可以得到一个无限趋近于 `0.1` 的表示方式。这也就是计算精度丢失的根本来源
- 这是我们无法避免的，换语言也不能避免。常用的处理方式有两种
    1. 把需要计算的数字转换成整数，也就是乘以 `10` 的 `n` 次方。计算后再除回来。这样做相对保险
    2. 将计算结果保留到一定精度，然后与保留前的值求差。显然，如果计算结果 "正确"，那这个差应该是 `0`。然后，将这个差值与一个很小的数字比较，如果差值小于这个很小的数字，那就表示我们可以直接使用保留后的结果
- 第一种方式很好理解。比如我们要计算 `0.1 + 0.2`，那我们就先把他们都乘以 `10` 来计算 `1 + 2`，得到 `3`，结果再除以 `10` 就可以得到 `0.3`
- 对于第二种方式，可能有些人会问，那我们怎么知道这个 "很小的数字" 是多少？理论上来说这取决于实际的精度要求。但事实上，JavaScript 已经为我们内置了这个很小的数，叫 `Number.EPSILON`。请移步到这里查看：[文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)
- 虽然这个是 ES6 中才有的，但这个数本身就是一个常数，我们自己定义就没问题了。而且 MDN 页面上也给出了 Polyfill 的方案
- 有兴趣的朋友可以试试实现以上两种思路，其实代码都非常简单

那么，之所以提到这件事儿，是因为在这道题目中，我们需要处理小数。由于这道题的场景是计算交易金额/找零，那么我们可以认为，小数点后最多只可能有两位

因此，我们就都把所有的过程，按照单位为 `分` 去处理就可以了。比如，一元我们用 `100` 表示，"Quarter" 我们就用 `25` 表示。这样会在很大的程度上简化代码和计算

只是别忘了，输出的结果还是要以 `元` 为单位，那么我们在生成最终结果的时候，或者生成的过程中转换一下就好了

# 基本解法
## 思路提示
- 按照上面的思路，我们再来考虑一些实现中的细节问题。上面已经说了，建议在这道题中，把所有涉及到钱的计算都乘以 `100` 来处理
- 我们需要先构建关于面值和名称的参考数组。与 [罗马数字转换器](http://singsing.io/blog/fcc/intermediate-roman-numeral-converter/) 类似，在那道题中我们构建了一个用于存储每个罗马字符代表的阿拉伯数字的 `numArr`，以及一个用于存储所有罗马字符的 `strArr`。这两个数组可以通过索引来建立联系。对于这道题，同理，我们可以建立一个面值名称的数组，和每一个面值代表的钱数的数组，同样用索引来建立联系。就像这样：

```js
// 注意，这里给每种面值都乘了 100
var denomination = [1, 5, 10, 25, 100, 500, 1000, 2000, 10000];
var denominationName = ['PENNY', 'NICKEL', 'DIME', 'QUARTER', 'ONE', 'TEN', 'TWENTY', 'ONE HUNDRED'];
```

- 可能有些朋友会问，既然需要建立一一对应的关系，为什么不像这样，使用对象呢？

```js
var denominationObj = {
    PENNY: 1,
    NICKEL: 5,
    DIME: 10,
    QUARTER: 25,
    // ....
}
```

- 由于对象本身是无序的 (至少，我们不应该认为它是有序的)，我们在用 `for...in` 遍历对象的时候也就无法保证实际遍历的顺序。这样说虽然不够确切，因为默认会按照定义时候的顺序来遍历。但不同浏览器内核对 `for...in` 的实现也不尽相同，因此我们无法保证顺序一定是我们最开始定义的，详情请参考底下的链接。所以，不建议使用
- 对于这道题来说，由于我们希望的是从最大的 `10000` 也就是一百元开始尝试，然后尝试二十元，十元，五元，以此类推。因此，这里我还是建议使用两个数组去定义

## 参考链接
- [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)
- [罗马数字转换器](http://singsing.io/blog/fcc/intermediate-roman-numeral-converter/)